% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OptimizationFunctions.R
\name{phase1}
\alias{phase1}
\title{Function finding an initial feasible solution (provided it exists) to programs such as (24)}
\usage{
phase1(constFun, constRHS, constDir, constLambda = rep(0, length(constRHS)),
  x = 0, C = 10000, IterMax = 100)
}
\arguments{
\item{constFun}{List containing the functions \eqn{G_j}}

\item{constRHS}{Vector containing the bounds \eqn{gamma_j}}

\item{constDir}{Vector containing the direction of the constraints (\emph{e.g.} '=', '<=', ">=" )}

\item{constLambda}{Vector containing the the values of the parameters \eqn{\lambda_{j,M}}  (use default vector of 0's to solve classic generalized linear programs)}

\item{x}{Non-negative scalar representing the first point support to enter the procedure (default 0)}

\item{C}{Upper bound of the support of feasible distribution functions (default 1e4)}

\item{IterMax}{Maximum number of iterations for the procedure (default = 100)}
}
\value{
A list containing
\item{p}{Vector of point masses}
\item{x}{Vector of point supports}
\item{s}{Scalar}
\item{r}{Optimal value of the variable \emph{r} when the program is feasible and an optimal solution  exists}
\item{feasible}{Boolean indicating wether \emph{(p, x, s)} is a feasible solution to (24)}
\item{status}{Integer describing the final status of the procedure (0 => Reached a solution, 1 => the algorithm terminated by reaching the maximum number of iterations, 2 => the algorithm entered a cycle)}
\item{nIter}{Number of iterations reached when the procedure terminated}
\item{eps}{Opposite value of the inner optimization program when the procedure terminated}
}
\description{
Finds a feasible solution (provided it exists) to programs such as (24). It uses the generalized linear programming approach  described in Algorithm 2. We slightly generalize
this algorithm so that inequalities in (24) can be replaced by lower inequalities or equalities if desired.
}
\examples{

####
#### Finding a basic feasible solution (p, x, s) such that
####
#### sum(p)  = 1
#### sum(px) = 1
#### sum(px^2) = 2 + s
####
####

# Function for the integrals of the constraints inequality
constFun = rep(list(
function(x) 1,
function(x) x,
function(x) x^2 + s
),2)

# Direction of the inequality constraints
constDir <- rep(c("<=", ">="), each = 3)

# Values on the RHS of each inequality
mu0 <- 1
mu1 <- 1
mu2 <- 2

constRHS <- rep(c(mu0,mu1,mu2), 2)

# Lambdas for the objective function and the constraints functions
constLambda <- rep(c(0,0,1),2)

# Get a basic feasible solution
initBFS  <-  phase1(constFun, constRHS,constDir, constLambda)

# Check feasibility
with(initBFS, c(sum(p), sum(p*x), sum(p*x^2) + s))
}
