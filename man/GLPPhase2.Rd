% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OptimizationFunctions.R
\name{GLPPhase2}
\alias{GLPPhase2}
\title{Title}
\usage{
GLPPhase2(initBFS, objFun, constFun, constRHS, constDir, constLambda, objLambda,
  paramConsFun = NULL, paramObjFun = NULL, gamma = NULL, xf = 10000,
  IterMax = 100, err = 1e-06, rerr = 1e-04, factor = 1, scale = 196,
  objFuncIndic = FALSE)
}
\arguments{
\item{objFuncIndic}{}
}
\description{
Title
}
\examples{
####
#### Finding a the optimal probability measure (p,x) to the problem
####
#### max P(X > c)
#### s.t. sum(p)  = 1
####      sum(px) = 1
####      sum(px^2) = 2
####
#### where c is the 90th percentile of a standard exponential distribution
#### Note that the solution to this problem is known (see Theorem 3.3 of Bertsimas and Popescu)

# Function and parameters for the integral of the objective
objFun <- function(x,...) return(as.numeric(paramObjFun$c <= x))
paramObjFun <- list(c = qexp(0.9,rate))

# Function for the integrals of the constraints inequality
constFun = rep(list(
function(x,...) 1,
function(x,...) x,
function(x,...) x^2
),2)

# Direction of the inequality constraints
constDir <- rep(c("<=", ">="), each = 3)

# Values on the RHS of each inequality
# here we choose the moment of order 0, 1, and 2 of an exponential distribution
rate <- 1
mu0 <- 1
mu1 <- 1/rate
mu2 <- 2/rate^2

# Lambdas for the objective function and the constraints functions
constLambda <- rep(c(0,0,1),2)
objLambda <- 0

# Get a basic feasible solution
initBFS  <-  GLPPhase1(constFun, constRHS,constDir)

# Check feasibility
with(initBFS, c(sum(p), sum(p*x), sum(p*x^2)))

# Solve the optimization program of interest
output <- GLPPhase2(initBFS, objFun, constFun, constRHS,
                     constDir, constLambda, objLambda,
                     paramObjFun = paramObjFun, objFuncIndic = TRUE)

# Check that the output matches the analytical solution
CMsquare <- (mu2 - mu1^2)/mu1^2
delta <-  (paramObjFun$c/mu1-1)

data.frame(Algorithm = output$lB, Analytical = CMsquare/(CMsquare + delta^2))
}

