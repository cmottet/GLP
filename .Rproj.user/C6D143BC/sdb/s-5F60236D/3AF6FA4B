{
    "collab_server" : "",
    "contents" : "\nevalConst = function(x,constFun,paramConstFun){\n  output = matrix(0,nrow= length(constFun),ncol = length(x))\n\n  for (i in 1:length(constFun)) output[i,] = do.call(constFun[[i]],list(x = x,paramConstFun = paramConstFun))\n\n  return(output)\n}\n\ninnerOptimizationFunction = function(x,lpdual,phase,constFun,paramConsFun, objFun = NULL,paramObjFun = NULL)\n{\n  newcol = evalConst(x,constFun,paramConsFun)\n\n  if (phase == 1) output = -lpdual%*%newcol\n  if (phase == 2) output =  lpdual%*%newcol -  objFun(x,paramObjFun)\n\n  return(output)\n}\n\n\n#' Title\n#'\n#' @param initBFS\n#' @param objFun\n#' @param constFun\n#' @param constRHS\n#' @param constDir\n#' @param constLambda\n#' @param objLambda\n#' @param paramConsFun\n#' @param paramObjFun\n#' @param gamma\n#' @param xf\n#' @param IterMax\n#' @param err\n#' @param rerr\n#' @param factor\n#' @param scale\n#' @param objFuncIndic\n#'\n#' @return\n#' @export\n#' @importFrom lpSolve lp\n#' @importFrom GenSA GenSA\n#'\n#' @examples\n#' ####\n#' #### Finding a the optimal probability measure (p,x) to the problem\n#' ####\n#' #### max P(X > c)\n#' #### s.t. sum(p)  = 1\n#' ####      sum(px) = 1\n#' ####      sum(px^2) = 2\n#' ####\n#' #### where c is the 90th percentile of a standard exponential distribution\n#' #### Note that the solution to this problem is known (see Theorem 3.3 of Bertsimas and Popescu)\n#'\n#' # Function and parameters for the integral of the objective\n#' objFun <- function(x,...) return(as.numeric(paramObjFun$c <= x))\n#' paramObjFun <- list(c = qexp(0.9,rate))\n#'\n#' # Function for the integrals of the constraints inequality\n#' constFun = rep(list(\n#' function(x,...) 1,\n#' function(x,...) x,\n#' function(x,...) x^2\n#' ),2)\n#'\n#' # Direction of the inequality constraints\n#' constDir <- rep(c(\"<=\", \">=\"), each = 3)\n#'\n#' # Values on the RHS of each inequality\n#' # here we choose the moment of order 0, 1, and 2 of an exponential distribution\n#' rate <- 1\n#' mu0 <- 1\n#' mu1 <- 1/rate\n#' mu2 <- 2/rate^2\n#'\n#' # Lambdas for the objective function and the constraints functions\n#' constLambda <- rep(c(0,0,1),2)\n#' objLambda <- 0\n#'\n#' # Get a basic feasible solution\n#' initBFS  <-  GLPPhase1(constFun, constRHS,constDir)\n#'\n#' # Check feasibility\n#' with(initBFS, c(sum(p), sum(p*x), sum(p*x^2)))\n#'\n#' # Solve the optimization program of interest\n#' output <- GLPPhase2(initBFS, objFun, constFun, constRHS,\n#'                      constDir, constLambda, objLambda,\n#'                      paramObjFun = paramObjFun, objFuncIndic = TRUE)\n#'\n#' # Check that the output matches the analytical solution\n#' CMsquare <- (mu2 - mu1^2)/mu1^2\n#' delta <-  (paramObjFun$c/mu1-1)\n#'\n#' data.frame(Algorithm = output$lB, Analytical = CMsquare/(CMsquare + delta^2))\nGLPPhase2 = function(initBFS,\n                     objFun,\n                     constFun,\n                     constRHS,\n                     constDir,\n                     constLambda,\n                     objLambda,\n                     paramConsFun = NULL,\n                     paramObjFun = NULL,\n                     gamma = NULL,\n                     xf        = 1e4,\n                     IterMax   = 100,\n                     err       = 1e-6,\n                     rerr      = 1e-4,\n                     factor    = 1,\n                     scale = 196,\n                     objFuncIndic = FALSE)\n\n{\n\n  ###\n  ### Step 0 - Initialization of the optimization problem\n  ###\n\n  # Initialize output\n  output = list(p         = 0,\n                x         = 0,\n                r         = 0,\n                lastx     = NA,\n                lpdual   = rep(0,length(constFun)),\n                feasible  = initBFS$feasible,\n                status    = 1,\n                nIter     = 0,\n                dual_lB   = Inf,\n                primal_uB = -Inf,\n                eps       = Inf)\n\n  if (!initBFS$feasible) return(output)\n\n  uB =  Inf\n  lB   = -Inf\n  r         = 0\n\n  N = length(constRHS)\n\n  # Initialize the x\n  x = initBFS$x\n  feasible = initBFS$feasible\n\n  # Initialize the objective function of the Master Program\n  objectiveIn     = rep(0,length(x)+1)\n  objectiveIn[1]  = objLambda\n  objectiveIn[-1] = sapply(x,objFun,paramObjFun)\n\n  # Initialize the constraints matrix of the Master Program\n  constMat     = matrix(0,length(objectiveIn),nrow = length(constRHS))\n  constMat[,1] = constLambda   # which we defined as the last one in f.con\n  constMat[,-1] = evalConst(x,constFun,paramConsFun)\n\n  for (k in 1:IterMax)\n  {\n    ###\n    ### Master Program\n    ###\n    outOpt    = lp(direction = \"max\",\n                   objectiveIn,\n                   constMat,\n                   constDir,\n                   constRHS,\n                   compute.sens = TRUE,\n                   scale = scale)\n\n    if (outOpt$status !=0)\n    {\n      print(paste(\"The master problem does not converge. Error status \" ,outOpt$status))\n\n      x = x[-length(x)] ; status = outOpt$status\n      if (k ==1) xnew  = eps  =NA\n      break\n    }\n\n    r      = outOpt$solution[1]\n    p      = outOpt$solution[-1]\n    lpdual = outOpt$duals[1:N]\n    lB     = outOpt$objval\n    ###\n    ### Sub-program\n    ###\n\n    if (objFuncIndic & paramObjFun$c <= xf)\n    {\n      tmp = NULL\n\n      tmp[[1]] = GenSA(par       = 0,\n                       fn        = innerOptimizationFunction,# GenSA for GLOBAL max\n                       lower     = 0,\n                       upper     = paramObjFun$c,\n                       phase     = 2,\n                       lpdual    = lpdual,\n                       constFun = constFun,\n                       paramConsFun = paramConsFun,\n                       objFun   = objFun,\n                       paramObjFun   = paramObjFun)\n\n\n      tmp[[2]] = GenSA(par       = 0,\n                       fn        = innerOptimizationFunction,# GenSA for GLOBAL max\n                       lower     = paramObjFun$c,\n                       upper     = xf,\n                       phase     = 2,\n                       lpdual    = lpdual,\n                       constFun = constFun,\n                       paramConsFun = paramConsFun,\n                       objFun   = objFun,\n                       paramObjFun   = paramObjFun)\n\n\n      inOpt = tmp[[ which.min(c(tmp[[1]]$value,tmp[[2]]$value)) ]]\n    } else\n      inOpt = GenSA(par       = 0,\n                    fn        = innerOptimizationFunction,# GenSA for GLOBAL max\n                    lower     = 0,\n                    upper     = xf,\n                    phase     = 2,\n                    lpdual    = lpdual,\n                    constFun = constFun,\n                    paramConsFun = paramConsFun,\n                    objFun   = objFun,\n                    paramObjFun   = paramObjFun)\n\n\n    xnew  = inOpt$par\n    eps   = -inOpt$value\n    #     print(c(xnew ,xf,lpdual))\n\n    if (is.null(gamma)) status = eps > err\n    else {uB  = min(gamma*eps +  lB,uB)   ; status = as.integer( uB > lB + rerr*abs(lB) )}\n    #     print(c(lB,uB,gamma*eps ))\n    if ( !status ) break\n    if (xnew %in% x) {print(\"Cycle\") ;  status = 2 ;  break}\n\n    # Add the column with xnew to the problem and iterate\n    x            = c(x,xnew)\n\n    objectiveIn = c(objectiveIn,objFun(xnew,paramObjFun))\n    constMat    = cbind(constMat,evalConst(xnew,constFun,paramConsFun))\n  }\n\n  if (status == 0) {\n    x = x[p!=0]\n    p = p[p!=0]\n  }\n\n  output = list(p         = p,\n                x         = x,\n                r         = r,\n                lpdual    = lpdual,\n                feasible  = feasible,\n                lB        = min(factor*lB,factor*uB),\n                uB        = max(factor*lB,factor*uB),\n                status    = status,\n                nIter     = k,\n                eps       = eps,\n                lastx     = xnew)\n  #   print(\"------------------------\")\n  return(output)\n\n\n\n}\n\n\n#' Title\n#'\n#' @param constFun\n#' @param constRHS\n#' @param constDir\n#' @param paramConsFun\n#' @param x\n#' @param xf\n#' @param IterMax\n#' @param scale\n#'\n#' @return a basic feasible solution\n#' @importFrom lpSolve lp\n#' @importFrom GenSA GenSA\n#' @export\n#'\n#' @examples\n#'\n#' ####\n#' #### Finding a basic feasible solution (p,x) such that\n#' ####\n#' #### sum(p)  = 1\n#' #### sum(px) = 1\n#' #### sum(px^2) = 2\n#' ####\n#' ####\n#'\n#' # Function objective to maximize\n#' objFun = function(x,...)   # H for the optim with convexity constraint\n#' {\n#'   c = paramObjFun$c\n#'   output = I(c <= x)\n#'   return(output)\n#' }\n#'\n#' # Function for the integrals of the constraints inequality\n#' constFun = rep(list(\n#' function(x,...) 1,\n#' function(x,...) x,\n#' function(x,...) x^2\n#' ),2)\n#'\n#' # Direction of the inequality constraints\n#' constDir <- rep(c(\"<=\", \">=\"), each = 3)\n#'\n#' # Values on the RHS of each inequality\n#' mu0 <- 1\n#' mu1 <- 1\n#' mu2 <- 2\n#'\n#' constRHS <- rep(c(mu0,mu1,mu2), 2)\n#'\n#' # Lambdas for the objective function and the constraints functions\n#' constLambda <- rep(c(0,0,1),2)\n#' objLambda <- 0\n#'\n#' # Get a basic feasible solution\n#' initBFS  <-  GLPPhase1(constFun, constRHS,constDir)\n#'\n#' # Check feasibility\n#' with(initBFS, c(sum(p), sum(p*x), sum(p*x^2)))\nGLPPhase1 <- function(constFun,\n                      constRHS,\n                      constDir,\n                      paramConsFun = NULL,\n                      x  = NULL,\n                      xf        = 1e4,\n                      IterMax   = 100,\n                      scale = 196)\n\n{\n  output <- list(p         = NA,\n                x         = NA,\n                r         = NA,\n                feasible  = FALSE,\n                bound     = Inf,\n                status    = 1,\n                nIter     = 0,\n                eps       = 0,\n                maxErrRel = 0)\n\n  ###\n  ### Step 0 - Initialization of the optimization problem\n  ###\n\n  # Initialize the rhs direction  and constant vectors\n  N <- length(constRHS)\n\n  # Initialize the x\n  if (is.null(x))  x <- 0\n\n  # Initialize the objective function of the Master Program\n  objectiveIn     <- rep(0,length(x)+1)\n  objectiveIn[1]  <- 1\n\n  # Initialize the constraints matrix of the Master Program\n  constMat <- matrix(0,length(objectiveIn),nrow = N)\n  constMat[constDir == \"<=\",1] <- -1\n  constMat[constDir == \">=\",1] <- 1\n\n  constMat[,-1] <- evalConst(x,constFun,paramConsFun)\n\n  for (k in 1:IterMax)\n  {\n    ###\n    ### Master Program\n    ###\n    outOpt <- lp(direction = \"min\",\n                   objectiveIn,\n                   constMat,\n                   constDir,\n                   constRHS,\n                   compute.sens = TRUE,\n                   scale = scale)\n\n\n    if (outOpt$status!=0)\n    {\n      print(paste(\"The master problem does not converge. Error status \" ,outOpt$status))\n      break;\n    }\n\n    r      <- outOpt$solution[1]\n    p      <- outOpt$solution[-1]\n    lpdual <- outOpt$duals[1:N]\n    bound  <- outOpt$objval\n\n    ###\n    ### Sub-program\n    ###\n    inOpt = GenSA(par       = 0,\n                  fn        = innerOptimizationFunction,# GenSA for GLOBAL max\n                  lower     = 0,\n                  upper     = xf,\n                  lpdual    = lpdual,\n                  phase     = 1,\n                  constFun = constFun,\n                  paramConsFun = paramConsFun)\n\n    xnew  <- inOpt$par\n    eps   <- inOpt$value\n    #     print(c(eps,r))\n    status <- as.integer(eps < 0 )\n\n    if ( !status ) break\n    if (xnew %in% x) {print(\"Cycle\") ;  status = 2 ;  break}\n\n    # Add the column with xnew to the problem and iterate\n    #     print(c(xnew,eps))\n    x <- c(x,xnew)\n\n    objectiveIn <- c(objectiveIn,0)\n    constMat    <- cbind(constMat,evalConst(xnew,constFun,paramConsFun))\n  }\n\n  if (k == IterMax) x <- x[-length(x)]\n  if (sum(p)> 0) {x <- x[p!=0]; p <- p[p!=0]  }\n\n  output = list(p         = p,\n                x         = x,\n                r         = r,\n                bound     = bound,\n                feasible  = (r == 0),\n                status    = status,\n                nIter     = k,\n                eps       = eps)\n  return(output)\n}\n\n\n",
    "created" : 1473885881015.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3861000016",
    "id" : "3AF6FA4B",
    "lastKnownWriteTime" : 1473887950,
    "last_content_update" : 1473887950011,
    "path" : "/src/BU/src/MyPackages/GLP/R/OptimizationFunctions.R",
    "project_path" : "R/OptimizationFunctions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}